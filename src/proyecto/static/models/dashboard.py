# -*- coding: utf-8 -*-
"""dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OMxaucgcMgdY1BNm2W4hAYeBAxawH9rA

# **Dashboard BI**<br>
Yahoo Finance: ETH Ethereum<br>
Estudiantes: Jimy Mora y Elizabeth Alzate<br>
Programa: Ingenier√≠a de software y datos<br>
Asignatura: Proyecto integrado V - L√≠nea de √©nfasis<br>
Docente: Andr√©s Felipe Callejas<br>
Fecha: 25-mayo-2025

Importaci√≥n de librer√≠as
"""

#!pip install streamlit
#!pip install pyngrok
#pip install streamlit pyngrok plotly pandas
#!npm install -g localtunnel

# Instalamos Streamlit y creamos un t√∫nel para la conexi√≥n al dashboard
# !pip install streamlit
# !npm install -g localtunnel

"""Pasos para creaci√≥n de las m√©tricas y creaci√≥n del dashboard"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import sqlite3
# import plotly.express as px
# import os
# import requests
# 
# # --- Configuraci√≥n de la base de datos y carga de datos ---
# 
# db_path = "enriched_historical.db"
# 
# if not os.path.exists(db_path):
#     st.write("-------Descargando la base de datos desde GitHub-------")
#     try:
#         url = "https://raw.githubusercontent.com/jimymora25/Tarea_2_Proyecto_Integrado_V/main/src/proyecto/static/data/enriched_historical.db"
#         response = requests.get(url)
#         if response.status_code == 200:
#             with open(db_path, "wb") as f:
#                 f.write(response.content)
#             st.write("‚úÖ Base de datos descargada correctamente.")
#         else:
#             st.error(f"‚ùå Error al descargar la base de datos: C√≥digo de estado {response.status_code}. Verifica la URL.")
#             st.stop()
#     except Exception as e:
#         st.error(f"‚ùå Error al descargar la base de datos: {e}. Verifica la conexi√≥n a internet.")
#         st.stop()
# 
# if not os.path.exists(db_path):
#     st.error("‚ùå Error: No se pudo encontrar la base de datos despu√©s de intentar descargarla.")
#     st.stop()
# else:
#     st.write("‚úÖ Base de datos disponible.")
# 
# @st.cache_data
# def load_data(path):
#     conn = sqlite3.connect(path)
#     df = pd.read_sql_query("SELECT * FROM enriched_historical", conn)
#     conn.close()
#     df["date"] = pd.to_datetime(df["date"])
#     return df
# 
# df = load_data(db_path)
# 
# st.write("‚úÖ Datos cargados correctamente")
# st.dataframe(df.head())
# 
# # --- C√°lculo de KPIs financieros ---
# 
# df["Price Change %"] = df["close"].pct_change() * 100
# df["Moving Average 30"] = df["close"].rolling(window=30).mean()
# df["Volatility"] = df["close"].rolling(window=30).std()
# df["Cumulative Return"] = (1 + df["close"].pct_change().fillna(0)).cumprod()
# df["Price Range"] = df["high"] - df["low"]
# std_close = df["close"].std()
# 
# # --- Configuraci√≥n del dashboard ---
# st.write("‚úÖ KPIs calculados correctamente!")
# st.title("üìä Dashboard de KPIs Financieros")
# 
# st.sidebar.header("Filtros de Fecha")
# start_date = st.sidebar.date_input("Fecha inicio", df["date"].min().date())
# end_date = st.sidebar.date_input("Fecha fin", df["date"].max().date())
# df_filtered = df[(df["date"] >= pd.to_datetime(start_date)) & (df["date"] <= pd.to_datetime(end_date))]
# 
# st.header("M√©tricas Clave")
# col1, col2, col3 = st.columns(3)
# col4, col5, col6 = st.columns(3)
# 
# if not df_filtered.empty:
#     with col1:
#         st.metric("üìà Tasa de Variaci√≥n (%)", f"{df_filtered['Price Change %'].mean():.2f}%")
#     with col2:
#         st.metric("üìâ Media M√≥vil (30 d√≠as)", f"{df_filtered['Moving Average 30'].iloc[-1]:.2f}")
#     with col3:
#         st.metric("‚ö° Volatilidad (STD M√≥vil 30 d√≠as)", f"{df_filtered['Volatility'].iloc[-1]:.2f}")
#     with col4:
#         st.metric("üìä Retorno Acumulado", f"{df_filtered['Cumulative Return'].iloc[-1]:.2f}")
#     with col5:
#         st.metric("üìè Rango de Precio (M√°ximo - M√≠nimo)", f"{df_filtered['Price Range'].mean():.2f}")
# else:
#     st.warning("No hay datos para el rango de fechas seleccionado.")
# 
# st.header("Tendencias de KPIs")
# 
# if not df_filtered.empty:
#     fig_change = px.line(df_filtered, x="date", y="Price Change %", title="Tasa de Variaci√≥n (%) a lo largo del tiempo")
#     st.plotly_chart(fig_change)
# 
#     fig_ma = px.line(df_filtered, x="date", y="Moving Average 30", title="Media M√≥vil (30 d√≠as) del Precio de Cierre")
#     st.plotly_chart(fig_ma)
# 
#     fig_volatility = px.line(df_filtered, x="date", y="Volatility", title="Volatilidad (Desviaci√≥n Est√°ndar M√≥vil)")
#     st.plotly_chart(fig_volatility)
# 
#     fig_return = px.line(df_filtered, x="date", y="Cumulative Return", title="Retorno Acumulado del Precio de Cierre")
#     st.plotly_chart(fig_return)
# else:
#     st.info("No se pueden mostrar los gr√°ficos ya que no hay datos en el rango de fechas seleccionado.")
#

# Iniamos streamlit en segundo plano y guardamos los errores o mensajes en el archhivo log.txt
!streamlit run app.py &> /content/log.txt &

# Se ejecuta dentro de Google Colab para obtener la clave del tunel local con que se acceder√° al dashboard
!curl https://loca.lt/mytunnelpassword

!npx localtunnel --port 8501