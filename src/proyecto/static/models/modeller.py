# -*- coding: utf-8 -*-
"""Modeller.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JMj6Ka2abEU--O-c8Oyh-5ICbKrhyGR5

# **Modelo ARIMA** <br>
Modelo autorregresivo para datos de series temporales<br>
Yahoo Finance: ETH Ethereum<br>
Estudiantes: Jimy Mora y Elizabeth Alzate<br>
Programa: Ingenier√≠a de software y datos<br>
Asignatura: Proyecto integrado V - L√≠nea de √©nfasis<br>
Docente: Andr√©s Felipe Callejas<br>
Fecha: 25-mayo-2025

Importaci√≥n de librer√≠as
"""

import pandas as pd
import sqlite3
import os
import logging
import joblib
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.graphics.tsaplots import plot_acf
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error

"""Descarga de los datos de GitHub y carga para el modelo"""

# Directorio de Google Colab
data_dir = "/content"

# Descargamos la base de datos desde GitHub
enriched_db_path = os.path.join(data_dir, "enriched_historical.db")
if not os.path.exists(enriched_db_path):
    print("üîÑ Descargando la base de datos desde GitHub")
    os.system(f"wget -O {enriched_db_path} https://raw.githubusercontent.com/jimymora25/Tarea_2_Proyecto_Integrado_V/main/src/proyecto/static/data/enriched_historical.db")

# Nos conectamos a la base de datos y cargamos los datos
conn = sqlite3.connect(enriched_db_path)
query = "SELECT year, month, day, close FROM enriched_historical"
df = pd.read_sql_query(query, conn)
conn.close()

# Convertimos la fecha a formato de fecha y la establecemos como √≠ndice
df["date"] = pd.to_datetime(df[['year', 'month', 'day']])
df.set_index("date", inplace=True)

# Recorremos e imprimimos la cantidad de registros en la base de datos
print(f"‚úÖ {len(df)} registros cargados desde la base de datos.")

"""Exploraci√≥n de datos"""

# Mostramos las primeras filas del DataFrame
print("Vista previa de los datos ETH:")
print(df.head())

# Resumen estad√≠stico
print("\nResumen estad√≠stico:")
print(df.describe())

"""Visualizaci√≥n de los datos"""

# Estilo de los gr√°ficos
sns.set_style("whitegrid")

# Gr√°fico de la serie de tiempo
plt.figure(figsize=(12, 6))
plt.plot(df.index, df["close"], label="Precio de cierre", color="blue")
plt.xlabel("Fecha")
plt.ylabel("Precio de cierre")
plt.title("Evoluci√≥n del precio de cierre")
plt.legend()
plt.show()

# En este gr√°fico, podemos analizar los datos desde el a√±o 2020 hasta la fecha, donde encontramos los siguentes puntos claves en la evoluci√≥n del precio:
# 2020 - 2021: El precio de cierre comienza cerca de los 200 - 300 USD y aumenta de manera gradual
# 2021: Se evidencia un pico notable superando los 4000 a mediados del a√±o y a finales del mismo, lega casi a los 5000 USD
# 2022 - 2023: A mediados de 2022 y principios de 2023 el precio cae y se estabiliza en un rango m√°s bajo, entre 1000 y 2000 USD
# 2023 - 2024: A mediados de 2023 y principios de 2024 el precio se estabiliza ligramente, manteni√©ndose debajo de 2500 USD
# 2024: El precio se eleva fuertemente a inicios del a√±o, alcanzando neuvamente los 4000 USD
# 2024 - 2025: El precio tiende a la baja, fluctuando alrededor de los 2500 y 2700 USD

# Histograma de precios de cierre
plt.figure(figsize=(8, 6))
sns.histplot(df["close"], bins=30, kde=True, color="green")
plt.xlabel("Precio de cierre")
plt.ylabel("Frecuencia")
plt.title("Distribuci√≥n de los precios de cierre")
plt.show()

# El gr√°fico muestra la distribuci√≥n de los precios de cierre, donde la mayor√≠a se agrupan entre 1700 y 1800 USD, donde se evidencia el pico m√°s alto de la frecuencia
# La distribuci√≥n muestra que es m√°s probable encontrar precios en el rango bajo (< 1000) y en el rango medio (alrededor de 1500-2000 USD)
# Cuando el precio aumenta, la frecuencia disminuye; por lo cual es menos com√∫n encontrar precios muy altos (cercanos a 5000 USD)

# Gr√°fico de autocorrelaci√≥n
plt.figure(figsize=(8, 8))
plot_acf(df["close"], lags=30)
plt.title("Autocorrelaci√≥n de la serie de tiempo")
plt.xlabel("Rezagos")
plt.ylabel("Autocorrelaci√≥n")
plt.show()

# Los rezagos van a 0 a 30
# Las barras del gr√°fico indica el coeficiente de autocorrelaci√≥n para un rezago en espec√≠fico
# El int√©rvalo de confianza (√°rea azul sombreada), indicando que si las barras salen del √°rea, significa que la autocorrelaci√≥n en ese rezago es estad√≠sticamente significativa
# Todas las barras por encima del int√©rvalo de confianza tienen una autocorrelaci√≥n positivas y fuerte, lo que indica una fuerte influencia en los valores futuros

"""Entrenamiento del modelo ARIMA"""

# Preparamos los datos para ARIMA
ts_data = df["close"].astype(float)

# Entrenamos el modelo ARIMA
model = ARIMA(ts_data, order=(3, 1, 2))
model_fit = model.fit()

print("‚úÖ Modelo ARIMA entrenado exitosamente.")

"""Evaluaci√≥n del error del modelo"""

# Calculamos la media del precio de cierre
media_close = df["close"].mean()

# Realizamos las predicciones con el modelo entrenado
y_pred = model_fit.predict(start=0, end=len(df)-1)

# Calculamoss el RMSE
rmse = mean_squared_error(df["close"], y_pred) ** 0.5

# Calculamos la proporci√≥n RMSE / Media
relacion_rmse_media = rmse / media_close

print(f"üîç RMSE del modelo ARIMA: {rmse:.2f}")
print(f"üìä Media del precio de cierre: {media_close:.2f}")
print(f"üìè Relaci√≥n RMSE / Media: {relacion_rmse_media:.4f}")


# El resultado nos indiica que en promedio, el modelo tiene un error del 5.25% con respecto al precio de cierre medio.
# Un RMSE entre el 5% y 10% de la media, se considera aceptable para modelos de predicci√≥n

#Evaluaci√≥n precciones vs datos reales
plt.figure(figsize=(12, 6))
plt.plot(df.index[-50:], df["close"].tail(50), label="Real", color="blue")  # √öltimos 50 datos reales
plt.plot(df.index[-50:], y_pred[-50:], label="Predicci√≥n", color="red", linestyle="dashed")  # √öltimos 50 valores predichos
plt.legend()
plt.title("Comparaci√≥n de datos reales vs. predicci√≥n")
plt.show()

# Se evidencia que el modelo se acerca a la tendencia general de los datos reales
# Hay momentos donde el comportamiento es similar, pero se perciben desviaciones o desfase

"""Guardado del modelo"""

# Directorio donde se guardar√° el modelo
models_dir = "/content/models"
os.makedirs(models_dir, exist_ok=True)

# Guardar el modelo
model_path = os.path.join(models_dir, "arima_model.pkl")
joblib.dump(model_fit, model_path)

print(f"‚úÖ Modelo ARIMA guardado en: {model_path}")